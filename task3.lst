     1                                  %define STRING_MAX_SIZE 100
     2                                  
     3                                  global _start
     4                                  
     5                                  section .bss
     6 00000000 <res 64h>                   input_string resb STRING_MAX_SIZE  ; Резервируем память под строку пользователя
     7 00000064 <res 64h>                   output_string resb STRING_MAX_SIZE ; Резервируем память под строку для вывода
     8                                  
     9                                  section .text
    10                                  _start:
    11                                      ; Читаем строку от пользователя
    12 00000000 4831C0                      xor rax, rax ; Системный вызов read(0)
    13 00000003 4831FF                      xor rdi, rdi ; Файловый дескриптор stdin(0)
    14 00000006 48BE-                       mov rsi, input_string
    14 00000008 [0000000000000000] 
    15 00000010 BA64000000                  mov rdx, STRING_MAX_SIZE
    16 00000015 0F05                        syscall
    17                                      
    18 00000017 4885C0                      test rax, rax
    19 0000001A 7852                        js exit_error ; Если RAX < 0, произошла ошибка
    20                                  
    21                                      ; rax содержит количество прочитанных байтов
    22 0000001C 4889C2                      mov rdx, rax 
    23                                  
    24 0000001F 80BA[FFFFFFFF]0A            cmp byte [input_string + rdx - 1], 10 ; Проверяем является ли последний символ переносом строки
    25 00000026 7503                        jne skip_dec
    26                                    
    27 00000028 48FFCA                      dec rdx ; Уменьшаем длину, чтобы не учитывать '\n'
    28                                      
    29                                  skip_dec:
    30                                      ; Вызов функции для записи в output_string перевёрнутой строки(кладём на стек адрес возврата) 
    31 0000002B 48BF-                       mov rdi, output_string
    31 0000002D [6400000000000000] 
    32 00000035 E840000000                  call reverse ; rdx - длина строки, rsi - адрес исходной строки, rdi - адрес буфера для записи
    33                                      
    34                                      ; Добавляем символ переноса строки в конец
    35 0000003A C682[64000000]0A            mov [output_string + rdx], byte 10
    36 00000041 48FFC2                      inc rdx
    37                                      
    38                                      ; Выводим результат
    39 00000044 B801000000                  mov rax, 1 ; Системный вызов write
    40 00000049 BF01000000                  mov rdi, 1 ; Файловый дескриптор stdout
    41 0000004E 48BE-                       mov rsi, output_string
    41 00000050 [6400000000000000] 
    42                                      ; rdx уже содержит длину строки(с учётом '\n')
    43 00000058 0F05                        syscall
    44                                  
    45 0000005A 4885C0                      test rax, rax
    46 0000005D 780F                        js exit_error ; Если RAX < 0, произошла ошибка
    47                                  
    48                                      ; Если записано не все, то тоже вернём ошибку
    49 0000005F 4839D0                      cmp rax, rdx
    50 00000062 750A                        jne exit_error ; Переход выполняется, если операнды не равны, результат не ноль(флаг нуля не установлен -> ZF = 0)
    51                                      
    52                                      ; Завершение программы без ошибок
    53 00000064 B83C000000                  mov rax, 60 ; Системный вызов exit
    54 00000069 4831FF                      xor rdi, rdi  ; Корректное завершение(0)
    55 0000006C 0F05                        syscall
    56                                  
    57                                  ; Выход с ошибкой
    58                                  exit_error:    
    59 0000006E B83C000000                  mov rax, 60
    60 00000073 BF01000000                  mov rdi, 1 ; Код возврата 1 (ошибка)
    61 00000078 0F05                        syscall
    62                                  
    63                                  ; Функция для разворота строки
    64                                  ; Вход: rdx - длина строки, rsi - адрес исходной строки, rdi - адрес буфера для записи
    65                                  ; Выход: перевернутая строка, записанная в буфер output_string
    66                                  reverse:
    67 0000007A 4989D0                      mov r8, rdx
    68 0000007D 4831D2                      xor rdx, rdx ; Индекс для записи в начало output_string 
    69 00000080 49FFC8                      dec r8 ; Индекс последнего элемента из input_string(rdx - 1)
    70                                  
    71                                  ; Цикл для записи значений из input_string в output_string
    72                                  .loop:
    73                                      ; Копируем байт из input_string в output_string
    74 00000083 4E8B1406                    mov r10, [rsi + r8]  ; Читаем байт
    75 00000087 4C891417                    mov [rdi + rdx], r10 ; Записываем байт
    76                                      
    77                                      ; Переходим к следующим позициям
    78 0000008B 48FFC2                      inc rdx
    79 0000008E 49FFC8                      dec r8
    80 00000091 79F0                        jns .loop; Продолжаем цикл пока не все элементы обработаны
    81                                      
    82                                  ; Завершение цикла(и возврат из функции)
    83                                  .end_loop:
    84 00000093 C3                          ret ; Снимаем адрес возврата со стека и добавляем его в счётчик команд
