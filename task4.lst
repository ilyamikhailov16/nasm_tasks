     1                                  %define MAX_NUM_LENGTH 7 ; Такая длина задана для корректной работы с числами от -32768 до 32767(с учётом вводимого символа переноса строки)
     2                                  
     3                                  global _start 
     4                                  
     5                                  section .data
     6 00000000 446F206E6F74207573-         letter_error_string db 'Do not use letters in numbers!', 10
     6 00000009 65206C657474657273-
     6 00000012 20696E206E756D6265-
     6 0000001B 7273210A           
     7                                      letter_error_string_length equ $ - letter_error_string
     8                                  
     9                                  section .bss
    10 00000000 ??????????????              first_num_str resb MAX_NUM_LENGTH
    11 00000007 ??????????????              second_num_str resb MAX_NUM_LENGTH
    12 0000000E ??????????????              result_str resb MAX_NUM_LENGTH
    13                                  
    14                                  section .text
    15                                  _start:
    16                                      ; Читаем первое число
    17 00000000 4831C0                      xor rax, rax ; Системный вызов read
    18 00000003 4831FF                      xor rdi, rdi ; Файловый дескриптор stdin
    19 00000006 48BE-                       mov rsi, first_num_str
    19 00000008 [0000000000000000] 
    20 00000010 BA07000000                  mov rdx, MAX_NUM_LENGTH
    21 00000015 0F05                        syscall
    22                                  
    23 00000017 4885C0                      test rax, rax
    24 0000001A 0F8831010000                js exit_error ; Если RAX < 0, произошла ошибка
    25                                  
    26                                      ; Преобразуем первое число и сохраняем результат преобразования в rax
    27 00000020 E878000000                  call str_to_int ; На входе rsi - указатель на буфер
    28 00000025 4889C3                      mov rbx, rax ; Сохраняем первое число в rbx, чтобы потом сложить со вторым
    29                                  
    30                                      ; Читаем второе число
    31 00000028 4831C0                      xor rax, rax ; Системный вызов read
    32 0000002B 4831FF                      xor rdi, rdi ; Файловый дескриптор stdin
    33 0000002E 48BE-                       mov rsi, second_num_str
    33 00000030 [0700000000000000] 
    34 00000038 BA07000000                  mov rdx, MAX_NUM_LENGTH
    35 0000003D 0F05                        syscall
    36                                  
    37 0000003F 4885C0                      test rax, rax
    38 00000042 0F8809010000                js exit_error ; Если RAX < 0, произошла ошибка
    39                                  
    40                                      ; Преобразуем второе число и сохраняем результат преобразования в rax
    41 00000048 E850000000                  call str_to_int ; На входе rsi - указатель на буфер
    42                                  
    43                                      ; Складываем числа
    44 0000004D E8FB000000                  call sum ; На входе rbx - первое число, rax - второе число, возвращаем в rax сумму
    45                                  
    46                                      ; Преобразуем результат в строку
    47 00000052 48BF-                       mov rdi, result_str
    47 00000054 [0E00000000000000] 
    48 0000005C E88E000000                  call int_to_str ; На входе rax - число(сумма) и rdi - указатель на буфер
    49                                  
    50                                      ; Добавляем символ переноса строки в конец
    51 00000061 C682[0E000000]0A            mov [result_str + rdx], byte 10 ; rdx содержит длину result_str после вызова int_to_str
    52 00000068 48FFC2                      inc rdx
    53                                  
    54                                      ; Выводим результат
    55 0000006B B801000000                  mov rax, 1 ; Системный вызов write
    56 00000070 BF01000000                  mov rdi, 1 ; Файловый дескриптор stdout
    57 00000075 48BE-                       mov rsi, result_str
    57 00000077 [0E00000000000000] 
    58                                      ; rdx содержит длину result_str
    59 0000007F 0F05                        syscall
    60                                  
    61 00000081 4885C0                      test rax, rax
    62 00000084 0F88C7000000                js exit_error ; Если RAX < 0, произошла ошибка
    63                                  
    64                                      ; Если записано не все, то тоже вернём ошибку
    65 0000008A 4839D0                      cmp rax, rdx
    66 0000008D 0F85BE000000                jne exit_error ; Переход выполняется, если операнды не равны, результат не ноль(флаг нуля не установлен -> ZF = 0)
    67                                      
    68                                      ; Выход из программы
    69 00000093 B83C000000                  mov rax, 60
    70 00000098 4831FF                      xor rdi, rdi ; 0 - успешное завершение
    71 0000009B 0F05                        syscall
    72                                  
    73                                  ; Функция для преобразования строки в число
    74                                  ; Вход: rsi - указатель на строку
    75                                  ; Выход: rax - число
    76                                  str_to_int:
    77 0000009D 4831C0                      xor rax, rax ; rax = 0 (результат)
    78 000000A0 4831C9                      xor rcx, rcx ; rcx = 0 (индекс)
    79 000000A3 4D31C0                      xor r8, r8   ; r8 = 0 ("флаг" знака: 0 - плюс, 1 - минус)
    80                                      
    81                                      ; Проверяем первый символ на знак минус
    82 000000A6 480FB616                    movzx rdx, byte [rsi]
    83 000000AA 80FA2D                      cmp dl, '-'
    84 000000AD 7509                        jne .loop ; Если не минус, начинаем обработку
    85                                      
    86 000000AF 41B801000000                mov r8, 1 ; Устанавливаем "флаг" отрицательного числа
    87 000000B5 48FFC1                      inc rcx   ; Пропускаем символ минуса
    88                                  
    89                                  ; Обрабатываем циклически цифры
    90                                  .loop:
    91 000000B8 480FB6140E                  movzx rdx, byte [rsi + rcx] ; Читаем один символ
    92                                  
    93                                      ; Проверяем достигли ли конца строки
    94 000000BD 80FA0A                      cmp dl, 10  ; '\n'
    95 000000C0 7424                        je .check_sign
    96 000000C2 84D2                        test dl, dl   ; '\0'
    97 000000C4 7420                        jz .check_sign
    98 000000C6 80FA20                      cmp dl, ' ' ; пробел
    99 000000C9 741B                        je .check_sign
   100                                      
   101                                      ; Проверяем ввод букв(вычитаем '9', т.е. 57 - крайний код, на котором заканчиваются цифры в ASCII)
   102 000000CB 80FA39                      cmp dl, '9'
   103 000000CE 0F8F89000000                jg letter_error
   104                                  
   105                                      ; Преобразуем символ в цифру(вычитаем '0', т.е. 48 - крайний код, с которого начинаются цифры в ASCII)
   106 000000D4 80EA30                      sub dl, '0'
   107                                      
   108                                      ; rax = rax * 10 + новая цифра(таким образом устанавливаем цифру в свой разряд)
   109 000000D7 48D1E0                      shl rax, 1
   110 000000DA 488D0480                    lea rax, [rax + rax*4]
   111 000000DE 4801D0                      add rax, rdx
   112                                      
   113 000000E1 48FFC1                      inc rcx ; Смещаем индекс дальше
   114 000000E4 EBD2                        jmp .loop ; Продолжаем цикл
   115                                      
   116                                  .check_sign:
   117                                      ; Если число отрицательное, меняем знак
   118 000000E6 4D85C0                      test r8, r8 ; Побитовое И(единица даст единицу)
   119 000000E9 7403                        jz .done
   120 000000EB 48F7D8                      neg rax ; Делаем число отрицательным
   121                                  
   122                                  .done:
   123 000000EE C3                          ret ; Возврат из функции
   124                                  
   125                                  ; Функция для преобразования числа в строку
   126                                  ; Вход: rax - число, rdi - указатель на буфер
   127                                  ; Выход: rdx - длина строки
   128                                  int_to_str:
   129 000000EF 4831C9                      xor rcx, rcx ; rcx = 0 (индекс)
   130 000000F2 4D31C0                      xor r8, r8   ; r8 = 0 ("флаг" знака: 0 - плюс, 1 - минус)
   131                                      
   132                                      ; Проверяем, отрицательное ли число(первый бит - единица)
   133 000000F5 4885C0                      test rax, rax
   134 000000F8 7909                        jns .convert ; Если положительное, переходим к конвертации
   135                                      
   136                                      ; Число отрицательное
   137 000000FA 41B801000000                mov r8, 1 ; Устанавливаем "флаг"
   138 00000100 48F7D8                      neg rax ; Делаем число положительным для обработки
   139                                      
   140                                  .convert:
   141 00000103 BB0A000000                  mov rbx, 10 ; Делитель
   142                                      
   143                                  ; Обрабатываем циклически цифры
   144                                  .loop:
   145 00000108 4831D2                      xor rdx, rdx        ; Обнуляем rdx перед делением
   146 0000010B 48F7F3                      div rbx             ; rax = rax / 10, rdx = остаток(путём деления на 10 получаем самый первый разряд в рассматриваемой в данный момент целой части)
   147 0000010E 80C230                      add dl, '0'         ; Преобразуем цифру в символ(теперь добавляя 48)
   148 00000111 88140F                      mov [rdi + rcx], dl ; Сохраняем символ
   149 00000114 48FFC1                      inc rcx 
   150                                      
   151 00000117 4885C0                      test rax, rax ; Проверяем, все ли цифры обработаны(целая часть должна быть нулём)
   152 0000011A 75EC                        jnz .loop ; Если нет, то продолжаем цикл
   153                                      
   154                                      ; Если число было отрицательным, добавляем минус
   155 0000011C 4D85C0                      test r8, r8
   156 0000011F 7407                        jz .reverse
   157                                      ; rcx после финальной итерации цикла показывает на байт за последним символом
   158 00000121 C6040F2D                    mov [rdi + rcx], byte '-'
   159 00000125 48FFC1                      inc rcx ; Теперь rcx содержит длину строки
   160                                      
   161                                  .reverse:
   162                                      ; Переворачиваем строку(т.к. первые разряды теперь стоят последними(т.е. в начале строки))
   163 00000128 4889CA                      mov rdx, rcx ; Сохраняем длину
   164                                      ; Задаём "указатели" для свопов
   165 0000012B 48FFC9                      dec rcx      ; rcx = последний индекс
   166 0000012E 4831DB                      xor rbx, rbx ; rbx = первый индекс
   167                                      
   168                                  .reverse_loop:
   169                                      ; Меняем местами символы(своп)
   170 00000131 448A0C1F                    mov r9b, [rdi + rbx]
   171 00000135 448A140F                    mov r10b, [rdi + rcx]
   172 00000139 4488141F                    mov [rdi + rbx], r10b
   173 0000013D 44880C0F                    mov [rdi + rcx], r9b
   174                                      
   175                                      ; Смещаем указатели
   176 00000141 48FFC3                      inc rbx
   177 00000144 48FFC9                      dec rcx
   178                                  
   179                                      ; Пока левый "указатель" меньше правого продолжаем цикл
   180 00000147 4839CB                      cmp rbx, rcx
   181 0000014A 7CE5                        jl .reverse_loop
   182                                  
   183                                  .done:
   184 0000014C C3                          ret ; Возврат из функции
   185                                  
   186                                  ; Функция для суммирования двух чисел
   187                                  ; Вход: rax - первое число, rbx - второе число
   188                                  ; Выход: rax - сумма
   189                                  sum:
   190                                      ; Складываем числа
   191 0000014D 4801D8                      add rax, rbx ; rax = rax + rbx
   192 00000150 C3                          ret
   193                                  
   194                                  ; Выход с ошибкой
   195                                  exit_error:    
   196 00000151 B83C000000                  mov rax, 60
   197 00000156 BF01000000                  mov rdi, 1 ; Код возврата 1 (ошибка)
   198 0000015B 0F05                        syscall
   199                                  
   200                                  ; Выход с ошибкой из-за ввода буквы
   201                                  letter_error:
   202 0000015D B801000000                  mov rax, 1 ; Системный вызов write
   203 00000162 BF02000000                  mov rdi, 2 ; Файловый дескриптор stderr
   204 00000167 48BE-                       mov rsi, letter_error_string
   204 00000169 [0000000000000000] 
   205 00000171 BA1F000000                  mov rdx, letter_error_string_length
   206 00000176 0F05                        syscall
   207                                  
   208 00000178 B83C000000                  mov rax, 60
   209 0000017D BF01000000                  mov rdi, 1 ; Код возврата 1 (ошибка)
   210 00000182 0F05                        syscall
